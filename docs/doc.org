#+title: Spheres-sounds
#+startup: indent showall
* dev

** starting up
- C-c M-j
- (require '[figwheel-sidecar-repl-api :as fw])
- (fw/start-figwheel!)
- (fw/cljs-repl)
then for the CSS that's in clj,-  M-x cider-connect-sibling-clj

** deployment
*** github-pages

- add a remote 'github' - git remote add github https://github.com/manandearth/spheres-rf-ha.git
- created a branch 'gh-pages' - git branch gh-pages
- checkout to it -  git checkout gh-pages
- need index.html at root with correct paths to css and js
- I had to comment out resources/public/resources/js from the .gitignore
- from the project.clj I had to delete ["garden" "once"] from the :preptasks
- lein clean
- lein cljsbuild once min
- git add . and git commit -m ""
- git push github gh-pages
- *ISSUE* - when I committed changed to the index.html in github website, I had to -> git pull github gh-pages

** cljs-bach

cljs-bach is required in the audio ns:

#+BEGIN_SRC clojure
(:require [cljs-bach.synthesis :refer [connect-> percussive adsr adshr sine square sawtooth add gain high-pass low-pass white-noise
      triangle constant envelope run-with destination current-time]])

;;defining the browser audio context:
(defonce context (cljs-bach.synthesis/audio-context))

#+END_SRC 
**** TODO look carefully at klangmeister
I am not sure how to arrange the namespaces, Klangmeister might give
me an idea

*** DONE create a multimethod ..
first thing that occured to me is to use cljs-bach builtin `add` to
put together a whole system in one sound I'll start with
frequency. basically:

#+BEGIN_SRC clojure
(defn pings
  [freq1 freq2]
  (connect->
   (add
    (sine freq1)
    (sine freq2)) 
   (gain 0.1)))

(-> (pings 440 420)
    (connect-> destination)
    (run-with context (current-time context)1))

#+END_SRC

That is for two frequencies so first I will need to
create the multimethod.  Then I will see if some orbit
values create anything interesting in any of the
systems.

** functionality

*** DONE toggle the selected system in the menu itself
make a dispatch on click to add the clicked name to :vis
in the db for example.

*** DONE toggle visibility of spheres from system
look into how to toggle within a system, if I do it the
*spheres-rf-ha* way -  it toggles visibility globally and
then a planet that is toggled off in the solar system for example
is toggled off in its own system (might be desired or not...).

*** DONE select attribute to examine

*** DONE flex the function according to attribute and system
perhaps we need a toggle for global and local.. so that
the scale changes/or not when zooming into a system.
-kind of solved it with global for frequency..

*** *THE KEYBOARD*
**** DONE one axis from /spheres-rf-ha/
copied and adjusted the code.

**** DONE add tooltip style data 
when hovering over a sphere-key in the keyboard have
something like "<sphere> distance from <sun> is <so and
so> km "

**** TODO add a keyboard key and a map 
for exaple the home row so something like:

| a     | s         | d       | f       | g      | h        | j        | k        | l         | ;       |
|-------+-----------+---------+---------+--------+----------+----------+----------+-----------+---------|
| "Sun" | "Mercury" | "Venus" | "Earth" | "Mars" | Jupiter" | "Saturn" | "Uranus" | "Neptune" | "Pluto" |
|-------+-----------+---------+---------+--------+----------+----------+----------+-----------+---------|

the letter can just be added to the name in the selected-spheres menu.

***** TODO library keys clojurescript -->> RE-PRESSED
https://github.com/gadfly361/re-pressed

#+BEGIN_SRC clojure 
:dependencies [[org.clojure/clojure "1.8.0"]
                 [org.clojure/clojurescript "1.10.238"]
                 [reagent "0.7.0"]
                 [re-frame "0.10.5"]
                 [garden "1.3.5"]
                 [ns-tracker "0.3.1"]
                 [cljs-bach "0.3.0"]
                 [com.cognitect/transit-cljs "0.8.239"]
                 [re-pressed "0.3.0"]] ;<<===THIS ONE


#+END_SRC

the author says:
If you have questions, I can usually be found hanging out in the clojurians #reagent slack channel (my handle is @gadfly361).

*** TODO make the gain slider do something...

*** TODO add envelope [3/6]
- [X] add a note function that takes [adshr]
- [X] add a chord function that does the same.
- [X] update the events and views
- [ ] a graphic representation
- [ ] a spec
- [ ] how to manipulate the graph?

input from user [adshr] 

*** Sliders for range of frequency - Major important for instrument usefulness

**** VIEWS
*sliders* element, It takes frequency range and rate
 that is something like this psuedo example:

#+BEGIN_SRC clojure
(defn interpolate [x]
  (let [selected-attr @(subscribe [::subs/selected-attr])
        spheres (subscribe [::subs/spheres])
        sorted-spheres (subscribe [::subs/sorted-spheres])
        global @(subscribe [::subs/global])
        y-range (subscribe [::subs/freq-range])
        y-1 (:min @y-range)
        y-2 (:max @y-range)
        x-1-global (apply min (map selected-attr @spheres))
        x-1-local (apply min (map selected-attr @sorted-spheres))
        x-2-global (apply max (map selected-attr @spheres))
        x-2-local (apply max (map selected-attr @sorted-spheres))]
    (if global
      (+ y-1 (* (- y-2 y-1) (/ (- x x-1-global) (- x-2-global x-1-global))))
      (+ y-1 (* (- y-2 y-1) (/ (- x x-1-local) (- x-2-local x-1-local)))))
    ))

#+END_SRC

I need to minimize the views so all the logic happens in
/events/ and /cofx/.

**** SUBS
At the moment all the flow happens in the /calc-freq-rate/:
#+BEGIN_SRC clojure
(reg-sub
 ::calc-freq-rate
 :<- [::spheres]
 :<- [::sorted-spheres]
 :<- [::global]
 :<- [::selected-attr]
 :<- [::freq-range]
 (fn [[spheres sorted-spheres global attr freq-range] _]
   (if global
     (let [high-point (apply max (map attr spheres))
           low-point (apply min (map attr spheres))
           range (- (:max freq-range) (:min freq-range))]
       (/ (- high-point low-point) range));the freq-range is what's audiable in hz.

     (let [high-point (apply max (map attr sorted-spheres))
           low-point (apply min (map attr sorted-spheres))
           range (- (:max freq-range) (:min freq-range))]
       (/ (- high-point low-point) range))) 
   ))

#+END_SRC

The problem is that these dependencies doesn't happen
necessarily in the right order..  The solution will be
in dispatching an event that calls :dispatch on coefx
that I have to define.


**** EVENTS

At the moment the dispatch is simple. I need to extend
and create coefx for what I rely on in several
dispatches.  The idea is that the db has to update
entirely when a parameter is changed before it executes
the /:audio/ event.

For debugging I should add the frequency's value to the
tooltip displayed with every /:audio/ dispatch.

** transit-cljs

*** TODO converting to edn or json and back

** visual design
*** DONE representation of the elements

glowing spheres

*** DONE the page look

dark bg, retro glow.

*** DONE some sort of scratch board where hovering will change the sounds.

perhaps the spheres themselves activated by hover or
some design of a visual instrument

*** TODO the green outline light on spheres in the systems-box should stay on for a selected system. 

*** DONE possible do it all a bit more concise so it will fit on the screen 

less padding on the instruction (:.guide)

*** TODO improve satelites representation inthe selected-spheres-box

now that the selected system parent looks better I
better improve the satelites that are only little white
circles at the moment

** data structure

generally there's an hirarchy of systems -> a system ->
sphere -> its attributes.

*** DONE add the synth's attributes to db

this way it could be accessed from the app by subscriptions.
- I could have a slider for the gain.
- The envelope could be graphically represented too... movable element

** sound and the data - relations

*** TODO how does each attribute relate to sound:

- If I represent the values as frequency, the greater
numbers are higher tones.. is that right?
a bigger planet is a higher note?


** ISSUES

*** TODO Throws a :
/re-frame: no handler registered for effect: {:input nil, :output nil} . Ignoring./
on every dispatch of :audio/
#+BEGIN_SRC clojure
(reg-event-fx
 :audio
 (fn [cofx [_ v]]
   (map dings v)))
#+END_SRC

perhaps has to do with cofx? routing the side effect to somewhere..

*** TODO adshr needs a spec


** NEW FEATURES 

*Looking to add something I didn't try before*

- auth -a `buddy` chapter on Lambda Island [[https://lambdaisland.com/episodes/buddy-authentication][here!]]
- tests [[https://lambdaisland.com/episodes/introduction-clojure-testing][lambdaisland tests intro]] and [[https://lambdaisland.com/episodes/testing-clojurescript][lambdaisland cljs tests]] and [[https://lambdaisland.com/episodes/acceptance-testing-sparkledriver][also this]] and lastly [[https://lambdaisland.com/episodes/generative-testing-clojure-test-check][this.]]
 
  
